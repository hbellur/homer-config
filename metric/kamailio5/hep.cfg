
loadmodule "mqueue.so"
loadmodule "db_mysql.so"
loadmodule "sipcapture.so"
loadmodule "sqlops.so"

modparam("mqueue", "mqueue", "name=queuehomer")
modparam("mqueue", "mqueue", "name=queue_sip_insert")
modparam("rtimer", "timer", "name=thomer;interval=3;mode=STATS_INSERT_CHILD;")
modparam("rtimer", "exec", "timer=thomer;route=STATS_HOMER")
#modparam("sqlops", "sqlcon","sqlhomer=>mysql://HOMER_DB_USER:HOMER_DB_PASSWORD@HOMER_DB_HOST:HOMER_DB_PORT/homer_data")
modparam("sqlops", "sqlcon","sqlhomer=>mysql://HOMER_DB_USER:HOMER_DB_PASSWORD@HOMER_DB_HOST:HOMER_DB_PORT/pcapture_data_h7")

#!ifdef DO_MYSQL_STATS
modparam("sqlops", "sqlcon","sqlstats=>mysql://HOMER_DB_USER:HOMER_DB_PASSWORD@HOMER_DB_HOST:HOMER_DB_PORT/homer_statistic")
#!endif

modparam("sqlops", "tr_buf_size", 4096)
#modparam("sipcapture", "db_url", "mysql://HOMER_DB_USER:HOMER_DB_PASSWORD@HOMER_DB_HOST:HOMER_DB_PORT/homer_data")
modparam("sipcapture", "db_url", "mysql://HOMER_DB_USER:HOMER_DB_PASSWORD@HOMER_DB_HOST:HOMER_DB_PORT/pcapture_data_h7")
modparam("sipcapture", "capture_on", 1)
modparam("sipcapture", "hep_capture_on", 1)
modparam("sipcapture", "insert_retries", 5)
modparam("sipcapture", "insert_retry_timeout", 5)
modparam("sipcapture", "capture_node", "homer01")
modparam("sipcapture", "nonsip_hook", 1)

event_route[sipcapture:request] {
/* Go to the main kamailio routing blocks if we get a SIP packet. Save source and destination ip for further use */
	#!ifdef DO_ISUP
	route(ISUP);
	#!endif

	#!ifdef DO_RTCP
	route(RTCP);
	#!endif

	$var(ip_family)         = $hep(0x001);
	#$var(ip_proto)         = $hep(0x002);
	$var(ip_proto)          = 17;
	$var(srcip)          	= $hep(0x003);
	$var(dstip)         	= $hep(0x004);
	$var(srcport)        	= $hep(0x007);
	$var(dstport)       	= $hep(0x008);
	$var(time_sec)        	= $hep(0x009);
	$var(time_usec)       	= $hep(0x00a);
	$var(correlation_id) 	= $hep(0x011);
	$var(hep_protocol)     	= $hep(0x00b);
	$var(capture_id)     	= $hep(0x00c);
	$var(vlan)              = $hep(0x012);
	$var(correlation_id)    = $hep(0x011);

	route(HEP_HEADER);
	route(IP_HEADER);

	if ($var(hep_protocol) == 1){
		return 1;
	}
	else {
		$var(utc) = $utimef(%Y%m%d);
		$var(table) = "hep_proto_" + $var(hep_protocol) + "_all_" + $var(utc);
		$var(json)           = $(hep(0x00f){s.escape.common});
		
        	$var(payload) = 0;
	
		jansson_set("integer", "timestamp", "$var(time_sec)", "$var(payload)");
		jansson_set("integer", "hep_protocol", "$var(hep_protocol)", "$var(payload)");
	
		switch($var(hep_protocol)) {	
			case  5:
				jansson_set("string", "protocol", "rtcp", "$var(payload)");
			break;
			case 34:
			case 38:
				jansson_set("string", "protocol", "report", "$var(payload)");
			break;
			case 53:
				jansson_set("string", "protocol", "json-dns", "$var(payload)");
			break;
			case 100:
				jansson_set("string", "protocol", "logs", "$var(payload)");
			break;
			default:
				return 0;
		}

		jansson_set("string", "data", "$var(json)", "$var(payload)");

		$var(homer_query) = "INSERT INTO " + $var(table) + " (gid, create_date, hep_header, ip_header, payload, raw) VALUES(10, '" + $utimef(%Y-%m-%d %H:%M:%S) + "', '" + $var(hep_header) +"', '" + $var(ip_header) + "', '" + $var(payload) + "', '" + $var(json) + "')";
		mq_add("queuehomer", "$var(correlation_id)", "$var(homer_query)");
		return 0;
	}
}

route[STATS_HOMER] {
	while (mq_fetch("queuehomer")) {
		sql_query("sqlhomer", "$mqv(queuehomer)");
	}
}

route[HEP_HEADER] {
	$var(hep_header) = 0;
        
	jansson_set("integer", "timestamp", "$var(time_sec)", "$var(hep_header)");
	jansson_set("string", "protocol", "hep", "$var(hep_header)");

        jansson_set("integer", "capture_id", "$var(capture_id)", "$var(hep_header)");
	jansson_set("string", "correlation_id", "$var(correlation_id)", "$var(hep_header)");
	jansson_set("string", "time_sec", "$var(time_sec)", "$var(hep_header)");
	jansson_set("string", "time_usec", "$var(time_usec)", "$var(hep_header)");
	jansson_set("string", "capture_ip", "$si", "$var(hep_header)");
	jansson_set("string", "version", "$hep(version)", "$var(hep_header)");
	jansson_set("integer", "proto", "$var(proto)", "$var(hep_header)");
	jansson_set("integer", "payload_len", "$ml", "$var(hep_header)");
}

route[IP_HEADER] {

        $var(ip_header) = 0;
	
	jansson_set("integer", "timestamp", "$var(time_sec)", "$var(ip_header)");
	jansson_set("string", "type", "ip", "$var(ip_header)");
	jansson_set("string", "protocol", "hep", "$var(ip_header)");

        jansson_set("integer", "ip_family", "$var(ip_family)", "$var(ip_header)");
	jansson_set("integer", "ip_proto", "$var(ip_proto)", "$var(ip_header)");
	jansson_set("integer", "source_port", "$var(srcport)", "$var(ip_header)");
	jansson_set("string", "source_ip", "$var(srcip)", "$var(ip_header)");
	jansson_set("integer", "destination_port", "$var(dstport)", "$var(ip_header)");
	jansson_set("string", "destination_ip", "$var(dstip)", "$var(ip_header)");
	jansson_set("integer", "vlan", "$var(vlan)", "$var(ip_header)");
}
